console.log('Request Data...'); // Тут я как бы говорю, что делаю запрос на сервер

// setTimeout(() => {
//     console.log('Preparing data'); // Как будто мы находимя на сервере и готовим некоторые данные 

//     const backendData = {  // Типа у нас тут есть какой то объект 
//         serverL: 'aws',
//         port: 2000,
//         status: 'working'
//     }

//     setTimeout(() => {
//         backendData.modified = true; //СДелали определенные манипуляции типа 
//         console.log('Data received', backendData) // Типа сервер подготовил некторые данные, эмулируем асихронность с помощью сеттайаутов. Тут мы типа получили с сервера объект
//     }, 2000)

// }, 2000); 

// Минус такой системы - это большая вложенность, вложенность коллбеков

const p = new Promise(function(resolve, reject) { // создаем новый промис - имя может быть любое. Это класс, поэтому в конструкцию мы должны передать какой то call back функцию
    setTimeout(() => {
        console.log('Preparing data'); // Как будто мы находимя на сервере и готовим некоторые данные 
        
        const backendData = {  // Типа у нас тут есть какой то объект 
            serverL: 'aws',
            port: 2000,
            status: 'working'
        }
        resolve(backendData) // В нашем случае мы вызвали сет таймаут, в нее передали функцию колбэк, и в конце ее асихронная операция закончена. Тут мы вызываем функцию резолв и говорим промису, что операция закончена.
    }, 2000) // Сейчас у нас есть некоторый Асихронный код, который мы обернули в Promise 

    // resolve - функция вызывается тогда, когда закончена Асихронная операция и закончена она успешно 
});

p.then(backendData => {  // Тут мы обратились к нашему промису и исп метод then (промис.когда выполнится);
    console.log('Promise resolved', backendData);               // тут функция выполнится, когда закончится асихронная операция, то есть выполнится метод resolve!!!
});

// Теперь нужно дописать функционал асихронный как был выше, но нужно исп еще один асихроную операцию  - сделать модификацию над Датой и сообщить, что data была получена
// Мы можем это сделать прямо внутри then (js36), но нужен доступ к backendData (js25). Чтобы получить досптуп до backendData , мы можем передать его в resolve() (js30)
// Тогда данный параметр будет доспен как просто объект Data как так ??? (я написал полным именем)



