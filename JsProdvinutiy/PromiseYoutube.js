// console.log('Request Data...'); // Тут я как бы говорю, что делаю запрос на сервер

// // setTimeout(() => {
// //     console.log('Preparing data'); // Как будто мы находимя на сервере и готовим некоторые данные 

// //     const backendData = {  // Типа у нас тут есть какой то объект 
// //         serverL: 'aws',
// //         port: 2000,
// //         status: 'working'
// //     }

// //     setTimeout(() => {
// //         backendData.modified = true; //СДелали определенные манипуляции типа 
// //         console.log('Data received', backendData) // Типа сервер подготовил некторые данные, эмулируем асихронность с помощью сеттайаутов. Тут мы типа получили с сервера объект
// //     }, 2000)

// // }, 2000);   !!! СНАЧАЛА СРАБАТЫВАЕТ ВНЕШНЯЯ ОБОЛОЧКА, ПОТОМ ВНУТРЕННЯЯ 

// // Минус такой системы - это большая вложенность, вложенность коллбеков

// const p = new Promise(function(resolve, reject) { // создаем новый промис - имя может быть любое. Это класс, поэтому в конструкцию мы должны передать какой то call back функцию
//     setTimeout(() => {
//         console.log('Preparing data'); // Как будто мы находимя на сервере и готовим некоторые данные 
        
//         const backendData = {  // Типа у нас тут есть какой то объект 
//             serverL: 'aws',
//             port: 2000,
//             status: 'working'
//         }
//         resolve(backendData) // В нашем случае мы вызвали сет таймаут, в нее передали функцию колбэк, и в конце ее асихронная операция закончена. Тут мы вызываем функцию резолв и говорим промису, что операция закончена.
//     }, 2000) // Сейчас у нас есть некоторый Асихронный код, который мы обернули в Promise 

//     // resolve - функция вызывается тогда, когда закончена Асихронная операция и закончена она успешно 
// });

// p.then(backendData => {  // Тут мы обратились к нашему промису и исп метод then (промис.когда выполнится);
// // тут функция выполнится, когда закончится асихронная операция, то есть выполнится метод resolve!!!
//     return new Promise((resolve, reject) => { // Сделаем еще одну асихронную операцию внутри промиса нового
//         // ранее на js38 я создавал новую переменную промиса через конст, а сейчас ее верну!
//         // в then выше я получи некоторые данные, далее вернул новый промис, а теперь мы не создаем новую переменную с промисом, а просто пишем .then вписываем объект и функцию, что надо сделать
//         setTimeout(() => {
//             backendData.modified = true; //СДелали определенные манипуляции типа 
//             resolve(backendData) // (а если поставить тут reject - то она выведет в ошибку (.catch). Тут мы сообщаем методу resolve что он завершился! Добавили объект, чтобы был доступ ниже по коду у метода then
//         }, 2000)
//     })

//     // p2.then(backendData => {   //  Аналогично передали объект ((ТЕПЕРЬ ВЕСЬ ЭТОТ КУСОК НЕ НУЖЕН , МЫ ПЕРЕДАЛИ ПРОМИС ЧЕРЕЗ return))
//     //     console.log('Data received', backendData); // Все сработало как надо, мы модифицировали наш объект и логика кода работает через промисы 
//     // })
// })
// .then(backendData => {
//     backendData.fromPromise = true;
//     return(backendData); // Если не вернуть, то я не увижу backendData уже внизу! Возвращаться нужно. Необязательно возвращать промисы, можно просто вернуть объекты и потом их модифицировать
// }) // Запись через точку называется ЧЕЙН - (пер. ЦЕПЬ). В целом мы модем наш p переменную передавать между модулями и функциями и выолнять то, что нам нужно 
// // выпоняется сначала одно потом второе и тд

// .then(function(backendData) { // тут я просто сделал обычную функцию просто так
//     console.log('Modified Data', backendData);
// })

// .catch(() => console.error('Error: Ошибка Пиздец'))   // Метод, который мы можем в принципе добавлять куда угодно, если есть ошибка, будет выпадать этот метод
// .finally(() => console.log('finally')) // этот метод промиса будет вызван в любом случае не зависимо от успехов и ошибок. 




// Теперь нужно дописать функционал асихронный как был выше, но нужно исп еще один асихроную операцию  - сделать модификацию над Датой и сообщить, что data была получена
// Мы можем это сделать прямо внутри then (js36), но нужен доступ к backendData (js25). Чтобы получить досптуп до backendData , мы можем передать его в resolve() (js30)
// Тогда данный параметр будет доспен как просто объект Data как так ??? (я написал полным именем)
// Промисы хороши, тк он может обрабаывать какие то ошибки, если мы отправили не те данные и иная ошибка.
// Если мы будем использовать подход коллбэков, то все нужно будет делать через  if , вдруг ошибка, вдруг что

// Есть Еще фишки в промисах и помогут при асихроннастях
// Создаим функцию слип, которая будет создавать определенную задержку
// const sleep = ms => {  
//     return new Promise(resolve => {
//         setTimeout(() => resolve(), ms)
//     })
// }; // Тут у нас есть функция ms , которая возвращает promise, которая вызывает метод резолв через определенное кол-во милисек, которые мы передаем

let sleep = function(ms) {  
    return new Promise(function(resolve) {
        setTimeout(function() { 
        resolve()
        }, ms)
    })
};


// sleep(2000) //(можно через точку прямо сюда then записать)
// .then(() => console.log('After 2 sec'))

// sleep(3000).then(() => console.log('After 3 sec')) // А тут просто 3 сек, но запись немного удобнее.

Promise.all([sleep(2000), sleep(5000)]) // тут передаем массив промисов, функция слип возвращает промис . У глобально класса Промис есть метод ОЛЛ вот мы его исп
.then(() => {
    console.log('All promises') // это сообшение появится, когда выполнятся все остальные Промисы (ими могут быть запросы к серверу и тд)
})

Promise.race([sleep(2000), sleep(5000)]) // тут опять массив из промисов и нвоый метод рэйс
.then(() => {
    console.log('Race promises') // это сообшение появится, когда выполнится первый промис
})