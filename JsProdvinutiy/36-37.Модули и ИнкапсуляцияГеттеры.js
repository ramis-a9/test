// // Инкапсуляция - это отделение и сокрытие от внешнего мира внутренеситей программы - переменных, функция и тд. 
//     // 1) Это защита от вмешательства пользователя. 
//     // 2) мы всегда сможем без последтсвией влезать и улучшатть нашу программу
//     // 3) Удобно, когда внутрянка программы скрыта, а мы исп только результат 

//     function User (name, age) {
//         this.name = name;
//         // this.age = age;  Это было
//         let userAge = age; // Это добавили. Теперь мы даже получить возраст не можем
//         // Чтобы работать с такими переменными, нужно исп такие понятия как Геттеры и Сеттеры 
//         // Геттеры и сеттеры - это методы нашего объекта, ктотрые позволяют изменять или получать данные, чтобы не было возможности рабоать на прямую с ними. Это делает наш оюъект более безопасным

//         // сначала делаем Геттер
//         this.getAge = function() {  // создаем новый метод
//             return user.age; // (сейчас мы пока что только просто возвращаем данные, а не выводим) Таким образом мы можем получать возраст, который записан в нашем конкретном объекте
//         };

//         // Установка Сеттеров 
//         this.setAge = function(age) { // СТавим в аргумент AGe тк будем его изменять. Этот метод нашего объекта будет устанавливать какое то значение.  
//            if (typeof age === 'number' && age > 0 && age < 110) { // C помощью сеттеров мы можем проверить тип данных , который к нам пришел - user.age = 20 - так не сможем   
//                 userAge = age;
//            } else {
//                 console.log('Недопустимое значение');
//            }
//         };

//         this.say = function() {
//             console.log(`Имя пользователя ${this.name}, возраст: ${this.userAge}`)
//         };
//     };

//     let user = new User('Ivan', 25)
//     console.log(user.name);
//     console.log(user.userAge);
//     user.say();
//     console.log(user.getAge()); // А вот сейчас, если мы исп консоль, мы получим даже цифры. В этом и есть смысл таких геттеров
//     user.setAge(29);
//     console.log(user.getAge());
    
//     // НО здесь есть проблема, пользователь несколькими командами стандартными может поменять все значения
//     // Именно для этого и нужна инкапсуляция

// function User(name, age) {
//     this.name = name;
//     let userAge = age;
//     this.getAge = function() {
//         return userAge;
//     }

//     this.setAge = function(age) {
//         if (typeof age === 'number' && age > 0 && age < 110) {
//             userAge = age;
//         } else {
//             console.log('Возраст не верный!')
//         }
//     }

    
// };

// let user1 = new User ('Ivan', 28)
// user1.setAge(30);
// console.log(user1.getAge()); // А вот сейчас мы видим цифру!! метод ретёрн только возвращается, через консоль лог видим, по другому нет!

// let user2 = new User ('Ivan', 28)
// console.log(user2.age);

           

            //  МОДУЛИ - они созданы для того, чтобы скрыть внутренние части реализации скрипта

    // Пример - программы свои мы делим на модули (как сборник рассказов, все раздельно)
        // Моудли 1) Самодостаточно и независимы - могут имзеняться и не зависить от других модулей, даже удаляться
        // 2) Чистоты в глобальных переменных, позволяет содержать в чистоте глобальное пространство
        // 3) Конфликтных имен не будет, ведь все данные существуют только в его области видимости
        // 4) Инкапсуляция позволяет менять внутрненнести безболезненно и в других даже проектах.

    // let app = {
    //     data: 45
    // };
    // console.log(app);

    // сейчас у нас есть этот объект, но самое интересное, он будет виден даже за пределами скриптового файла, на всей html тк ничем он не окружен!
    // сейчас создам еще main.js там будет тестить 
    // там мы получили ошибку, тк  апп уже есть тут, в этом и заключается чистота глобального пространства, чтобы не было переменных, точбы перебивать других
    //  мы будем исп инкапсуляцию чтобы скрывать конструкции какие то

    // let number = 1; // Прием модуль 1ый) Анонимная самовызывающаяся функция
    // // она вызывается здесь и сейчас, тк в будущем мы не сможем вызвать ее без имени и она вывзывает саму себя!

    // (function() {
    //     let number = 2;
    //     console.log(number);
        
    //     return console.log(number + 3 );
    // }()); // Это и есть простейши модуль и его нет в глобальном поле. ФАНКШЕН ЭКСПРЕШЕН ЭТО!! ТК Есть внешние скобки в начале и вконце. через () скобочки сейчас мы  ее вызвали и у нас получилась самовызывающаяся функция и это наш модуль
    // ЕСЛИ ФАНКШЕН ДЕКЛАРЕЙШЕН - то оно не бывает анонимной, у нее всегда должно быть имя
    // console.log(number); // сейчас мы получили только 1, тк функция еще не вызвана у нас, чтобы вызвать в конце () ставить нужно

    // 2ой прием создания модуля - Использования объектного интерфейса
    // let user = (function() {  //тут опять ФАНКШЕН ЭКСПРЕШЕН, функция сама вызовется, а результат ее работы поместится в переменную юзер
    //     let privat = function() {
    //         console.log('Im a privat');  // эту функцию мы оставим приватной, чтобы ее получить, нам нужно было бы написать геттер.
    //     }
    //     return { //вернем объект, в него засунем метод 
    //         sayHello: function(){
    //             console.log('Hello');
    //         }
    //     };
    // }());

    // console.log(user);
    // console.log(user.sayHello());
    // Сейчас мы видим что Прайват у нас скрыт и остался приватным, мы его не видим совсем, это как раз и есть пример инкапсуляции

        // Теперь 3ий подход - теперь наши методы изначально будут приватными - скрытми снаружи и мы веведем только те, что нам нужны
        
        let user = (function() {  
            let privat = function() {
                console.log('Im a privat');  
            };
            let sayHello = function() {
                console.log('Hello'); // Сейчас мы скрыли нашу функцию от какогто воздействия. Сейчас это не метод, а полноценная функция.
            };  // Сейчас ПРАЙВАТ и СЕЙХЕЛЛО - это как внутренние детали двигателя. Мы не можем исп их извне
            return { 
                sayHello228: sayHello // Мы сюда просто передаем готовую функцию, которая уже является приватной
            };
        }()); // 3ий метод - мы создаем уже нужные нам методы и они остаются приватными, в ретерне задаем любое название и вписываем нужную функцию (метод). Мы возвращаем, только если нам нужно метод который уже существует !
    
        console.log(user);
        console.log(user.sayHello228());
