'use strict';

//События - это сигнал от браузера о том, что что то произашло. Это клик, двойной клик мышью, когда убираем мышку с элемента и т.д
    //..прокрутка колесика, отправка данных форме...прям все , чем занимается пользователь

//Обработчик события - это функция ,которая срабатывает, как только событие произашло. 

//Для назначения Обработчиков событий в JS у нас есть 3 способа:
    // 1) Исп астрибут HTML - она может передать нашу функцию прямо в код. (такой способ не рекомендуется исп)
        // Прописываем в код html - onclick выглядит так:
            // <button onclick="alert('Вы нажали первую кнопку')" id="btn">Нажми меня</button>
            //  Тут мы исп. сначала двойные кавычки, а потом одинарные, тк будет конфликт если и то и другое исп.
    
    // 2) Исп. свойство DOM для событий. (через js файл)
        let btn = document.querySelectorAll("button"); //Это псведомассив всех Тэгов на сайте.
        // btn[0].onclick = function() {  //Функция, чтобы действие потом выполнялось все время , а не 1 раз.
        //     alert('Вы нажали на первую кнопку');
        // }; //но здесь, если мы их исп. - мы можем назначить только 1 функцию на 1 элемент.
        // btn[0].onclick = function() {  // А тут функция стерла первую функцию и выдает только свое действие.
            //     alert('Вы ОПЯТЬ нажали на первую кнопку');
    // 3) Правильный метод. В Виде 
        // btn[0].addEventListener('click', function() {   //здесь 2 агрумента - 1) Событие, которое должно произайти. 2) Функция, которая активируется после.
        //     alert('Вы нажали на первую кнопку');
        //     // alert('Вы нажали опять нажали на первую кнопку'); // Тут даже без клика вышло второе действие.
        // }); 
         
        // btn[0].addEventListener('click', function() {   //здесь 2 агрумента - 1) Событие, которое должно произайти. 2) Call Back Функция, которая активируется после.
        //     // alert('Вы нажали на первую кнопку'); // Комментируем, первое, чтобы сработало другое действие, как повторное.
        //     alert('Вы нажали опять нажали на первую кнопку'); // Здесь функция не перезатерла старую, как во втором ВАРИАНТЕ.
        // });  

        // btn[0].addEventListener('mouseenter', function () {  //Событие - мышь пришла в предел элемента.
        //     alert("Вы навели на первую кнопку");
        // }); 


// Объект event или e - Если нам нужно что то проверять условием или получать доп информацию при наведение и Т.д, мы его исп. Он имеет свои методы и свойства т.к. это объект
    // btn[0].addEventListener('click', function(event) {   //передали в аргумент call-back функции. Или можно просто букву - e
    //     console.log(event);
    //     let target = event.target;
    //     target.style.display = 'none'; //здесь, когда я кликну на первую кнопку, она исчезнит, ее стиль будет - none. Для этого и нужен объект event.
    //     // console.log('Произашло событие: ' + event.type + ' на элементе ' + event.target); // тут мы написали event.type - это свойство, которое скажет, что произашло, а event.target - (или цель) скажет, на чем именно
    // }); 
    

    // 4) Есть такое понятие как всплытие событий. Сначала работает событие привязанное именно к кнопке, а потом на обертку - на wrapper. Иерархия выполнения снизу - вверх идет.
            // Таргет верный будет - button и там и там, но если мимо нажать, цель будет уже Div и сработает более большая компанду по иерархии.
        let wrap = document.querySelector('.wrapper'); // здесь через точку т.к. это класс ! (ТУТ МЕНЯЛИ HTML - может не работать код сверху!)

        btn[0].addEventListener('click', function(event) {   //передали в аргумент call-back функции. Или можно просто букву - e
            console.log('Произашло событие: ' + event.type + ' на элементе ' + event.target); // тут мы написали event.type - это свойство, которое скажет, что произашло, а event.target - (или цель) скажет, на чем именно
        }); 

        wrap.addEventListener('click', function(event) { 
            console.log('Произашло событие: ' + event.type + ' на элементе ' + event.target); 
        }); 

        // Всплытие событий - это когда обработчик событий срабатывает сначала на самом вложенном элементе, затем на родителе, если есть и выше и выше.


    // 5) Отмена определенных событий.
        let link = document.querySelector('a');

        link.addEventListener('click', function(event) {
            event.preventDefault(); //Круглы скобки, т.к. это действие. Теперь, когда я кликну на ссылку, ничего не происходит, в этом и смысл этой команды.
            console.log('Произашло событие: ' + event.type + ' на элементе ' + event.target);
        });
    
    // 6) Правильное назначение одного и того же обработчика событий, на множество элементов. 
        btn.forEach(function(item) { // в методе исп. item, номер и сам массив
            console.log(item);
            item.addEventListener('mouseleave', function() {   // Команда, когда мы мышкой выходим из объекта. Здесь мы засунули Обработчик события в каждый Batton. ЗАГЛАВНОЕ НА mouseleave именно - на Leave НЕ ДОЛЖНО БЫТЬ! НЕ РАБОТАЕТ!
                console.log('Вышли!');
            });
        });
        // Перебирать при помощи цикла не очень корректно, а через foreach самое то. Но все равно допускается, просто нарушение негласных правил.