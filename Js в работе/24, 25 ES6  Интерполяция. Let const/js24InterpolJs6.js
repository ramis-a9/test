// ВОЗМОЖНО ФОРМАТА ES6
// let const - новый формат объявления
// циклы for of 


// Интерполяция - это более простой способ вставить переменную или выражение
let name = 'Ivan',
    age = '30',
    mail = 'ex@mail.ru';

    // Если бы я хотел вывести все 3 переменные в алерт или на страницу, мне надо было делать так:
document.write('Пользователю ' + name + " " + age + " лет. Его почтоый адрес: " + mail);   // Это самая примитивная команда, которая выводит сообщение на страницу  

// Интерполяция позволит все это сверху сократить. Для этого используем другой вид кавычек - который на букве Тильда
document.write(`Пользователю ${name} ${age} лет. Его почтоый адрес: ${mail}`);
// Это уже фича ES6 станарта    

// let func = function() {
//     console.log(this); // Window
//     function func2 () {
//         console.log(`Внутри функции ${this}`); // window все равно
//     }
//     func2();
// };
// func();



// let func = () => {
//     console.log(this); // Window
//     func2 = () => console.log(`Внутри функции ${this}`); // window (даже в строгом режиме)
//         func2();
// }; 
// func();

// let и const  - эти переменные видны лишь в блоке кода, ограниченными фигурными скобками
//  - создаются (видятся) только тогда, когда до них дошла очередь
//  - при исп let или const для каждоый интерации создается своя перменная!!! Смотри ниже

function makeArray() {
    var items = [];

    for (var i=0; i < 10; i++) {
        var item = function() { // Функция в коробочке 
            console.log(i);
        }
        items.push(item); // запушить - добавить 
    }

    return items;
};

var arr = makeArray();

arr[1](); // здесь мы вызвали 2ую функцию, а круглы скобки это как бы для того, чтобы вызвать функцию! Действие же это
arr[3]();
arr[7](); // мы получили здесь 10 по всем вызовам, т.к. мы объявили i чере var , и она стала одна на весь цикл. Наша i увеличивалась вместе с циклом
// только если поменять на let 


// Функции СТРЕЛОЧНЫЕ 

let fun = () => {  // запуск стрелочной функции
    console.log(this); 
}; 
// fun();
 
// 1) Функция анонимна, мы не можем дать ей какого то имени, можем поместить только в какую то переменную  и тогда уже вызвать
// 2) мы не сможем запускать эту функцию внутри себя (то есть сделать некую рекурсию)
// 3) Своего контекста стрелочная функция не имеет. Обычно контект у нее window НО 

let obj = {
    number: 5,
    sayNumber: function () {
        let say = () => {
            console.log(this); // если была бы классическая фукнция, то в коносоле мы бы увидел - Window, но стрелочные функции берут контектст у своего родителя
        }
        say();
    }
};
obj.sayNumber();

// Стрелочные функции чаще всего исп в обработчике событий, setinterval, setTimeout и в технологии аяКс

// let btn = document.querySelector('button');

// btn.addEventListener('click', function() {
//     let show = () => {
//         console.log(this);
//     };
//     show();
// });

function calcOrDouble(number, basis = 2) { // а тут мы прямо в функцию вставили значение - это уже ES6
    // basis = basis || 2; //это была старая тема ES5 формат. здесь такая хитрая тема, что сделали логику, если будет значение, то ОК , если нет , то 2
    console.log(number*basis); // Наша цель сделать это, при этом сделать так, чтобы basis имел в себе опр значение по умоланию
};
calcOrDouble(4, 5);
calcOrDouble(4);

// Классы

class Rectangle { //все классы с большой буквы писать нужно 
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    calcArea() { //здесь между свойствами и методами мы не ставим запятые, будет ошибка !
        return this.height * this.width; //тут считает площать нашего экзмепляра
    }
};

const square = new Rectangle(10, 10); // тут мы просто создали квадрат
console.log(square.calcArea()); // вызвали его метод.

// мы можем использовать элементы по умолчанию, чтобы например сделать элменты и настройки интерфейса.
//  ПРимер внизу
// class Rectangle { 
//     constructor(height, width = 20) { // вот тут использовали злемент по умолчанию на ширину 