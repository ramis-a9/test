"use strict";
//Основые объектоного программирования. Главную роль играет объект, он может в себе содержать методы и свойства, любой вид данных.
// Например - автомобиль - это объект, у него есть свои свойства - двигатель, ходовая и тд..
// Но у их потомков были разные двигатели, объемы, колеса и тд
// То есть у нас есть объект прототип с опр наобором характеристик и изменяю их немного, мы штампуем новые экзмепляры.
// Например - Прототип модельного окна, на основании которого, мы сделаем несколько новых не похожих друг на друга.
// Прототип пользовательского сайта и тд.
// ООП Это наука о том, как делать правильную архитектуру. 

// Отталавливание ошибок - помогает найти ошибку.
// Если мы хотим остановить выполнеине кода в опр. моменте именно по функциям. - Заходим в бразкер, в просмотр кода и вкладка Sourse.
// - есть такое понятие как BreakPoint-ы . (они останавливают).
// - после выставления брэйк поинтов (на цифры жмем), обновляем всю стр. Справа мы можем нажать на кнопки - старта дальше, или перескока на след Брэйкпоинт, и пропустить часть кода и смотреть результат следующией функции.
// - Call Stack - вывод всех функций, которые привели к данном результату.
// - Scope - переменные и данные, которые сейчас используются
// - Breackpoints - это те самые метки, которые мы поставили

// console.log('\u041f\u0440\u0438\u0432\u0435\u0442'); // Unicode в шестнадцетеричной система - Буква Л
// let л ='Л'.codePointAt(0).toString(16);

//DOM - document object modul - объектная модель документа. HTML код явл документом. И он представлен связанными узлами между собой
// Родительский тег - HTML. Дочерние Теги - Head, у него свои дочерние - meta, title, link
// у тега Body свои дочерние - div, button и тд
// Мы будем использовать весь документ - Dom . Тк это встроенный объект, у него есть методы и свойства.
// На нашей страницы мы можем назначать уникальные идентификаторы - id и по ним находить то, что нам нужно

let box = document.getElementById("box"); // Тут мы исп. встроенный объект document. Т.к. это тип данных объект, у него есть методы и свойства. Мы исп. его метод -
// getElementById, а в скобка пишем сам id, который нам нужен.
// id может быть только один на странице, т.к. он уникальный идентификатор.
// console.log(box);
// Можно получить элемент по тегу - но если посмотреть, тэгов очень много. Если запросить по тегу, то мы получим их в виде псевдомассива.
// Псевдомассив- синтаксически теже самые массивы, но без методов, таких как - pop push reduced и т.д.
 
let btn = document.getElementsByTagName("button"); // тут уже getElementS - несколько элементов и по тегу. И мы получим псевдомассив.
// console.log(btn);
// console.log(btn[0]);

let circle = document.getElementsByClassName("circle"); //Поиск по классу. Тут опять S - это значит, что мы получим псевдокллекцию.
// console.log(circle[2]);

let heart = document.querySelectorAll(".heart"); //здесь мы получаем селектор. Все пользуются этой командой. В скобках мы задаем любой СиСС селектор. К ним относятся и классы и айди и теги и атрибуты. А также вложеность всего перечисленного.
// Внимание, нужно указывать, что это за селектор. Если это класс - то ТОЧКУ, если id то РЕШЕТКУ, атрибут - Квадратые скобки и т.д.
// console.log(heart);
// console.log(heart[1]); //тут выделим второе сердце
//Доп. преимущества команды этой - Если есть какой то класс .wreaper .heart , а внутри вот класс heart - это указывается так и не будет ошибкой
// Псевдо массив полученный через querySelectorAll имеет 1 метод - это метод ForEach !! Он позволит перебрать и поработать с массивом.

let oneheart = document.querySelector(".heart"); // он очень похож на предыдущий метод, но тут мы получаем только первый элемент на странице.
// console.log(oneheart); //тут выделится первое сердце

// ЧТобы добраться до стилей, к нашей переменной мы добавляем слово style и пишем нужное свойство
box.style.backgroundColor = 'blue'; //Пишем название в форме Camale Case - когда слова выделяются только заглавными. В CSS мы бы поставили тире!
// здесь квадрат поменял свой цвет на синий. Если в гугле вбить background - то мы попадем на сайт и там сможем найти нужное свойство
btn[1].style.borderRadius = '100%'; // Мы сделали нашу вторую кнопку овальной
circle[0].style.backgroundColor = 'red';
circle[1].style.backgroundColor = 'yellow';
circle[2].style.backgroundColor = 'green';

// for (let i = 0; i < heart.length; i++) {  //но если мы хотим сделать одинаковые действия над каждый элементом из псевдомассива, мы исп цикл. 
//     heart[i].style.backgroundColor = 'blue';
// };

// heart.forEach(function (item, i, hearts) {  //Здесь тоже самое что и в цикле выше, но через метод foeach. 
//     item.style.backgroundColor ='blue'; //в скобках мы выполняем call back функцию, она выполнится ПОСЛЕ функции-метода foreach
// });   

let div = document.createElement('div'), //здесь мы создаем новый элемент. Создали элемент с тегом div - это стандартный тег, который обозначает блок
    text = document.createTextNode('Тут Был я');  //Написано - создай текстовую Ноду - текстовый узел. иногда нам нужно создавать и текстовые узлы. Это элементы без оболочек тега.
//Если мы хотим изменить элемент - мы не переписываем конструкции со стайл, а добавляем класс модификаторв с CSS, который будет прописан именно в CSS файле.
//раньше было свойство className, но оно старое, пользуемся новым - classList.
//classList - через точку можем писать действия с нашем классом - добавление, удаление, переключение - тогол,  проверка на содержание, или даже опр. количества обременненных классов к элементу. 

div.classList.add('black'); //здесь мы добавили class элементу. Большой ценностью у classList обладает методо ТОГОЛ, который позволяет переключать class в зависимости от каких то действий.
console.log(div);
console.log(text);

//Любой элемент можно вставить в страницу в конец, после элменета определенного, удалить или изменить, но только по отношению к определенному родителю.

// document.body.appendChild(div); //Этой командой мы вставили div в конце body на странице. Он вставился даже после скрипта, который подключен к верстке.
//Он работает для родительских Тегов
//Далее я сделал новый родительский тег .wrapper (прям так в html пишем, далее энтер, и вставил между открывшкой и закрывашкой)

let wrapper = document.querySelector('.wrapper');
// wrapper.appendChild(div); // тут мы поместили в родителя в wrarpper в конце

// div.innerHTML = 'Hello World!'; //Тут мы добавили текст, но можно добавлять даже HTML код в элементы. Этот метод может так делать.
// Тут включены стили, поэтому текст вышел белый, но по умолчанию он черный. СИ ЭС ЭС называетс правильно
// div.innerHTML = '<h1>Hellow world!</h1>'; // А здесь мы сделали заголовком - Эта команда опасна, ведь можно ввести вредноностный код сюда или скрипт
div.textContent = 'Hello World!'; //Тут мы добавили именно текст, чтобы обезопасить себя

document.body.insertBefore(div, circle[0]); //Дословно - Вставить перед! И тут 2 аргумента, что вставить и перед чем!
document.body.removeChild(circle[1]); // Эта команда удалит 2ой кружок. Он работает только внутр родительского элемента, но не внутри вложенного родительского элемента.
wrapper.removeChild(heart[1]); //А эта команда удалит сердечко внутри родительского элемента wrapper 
document.body.replaceChild(btn[1], circle[1]); // Здесь мы заменили элементы. Кнопку 2 переместили на место 2ого сердечка. Вторая кнопка пропала и встала на место второго сердечка, его тоже теперь нет.

